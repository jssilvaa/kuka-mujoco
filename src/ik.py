import time
from typing import Tuple

import mujoco
import mujoco.viewer
import numpy as np 

def __load_model(path: str) -> Tuple[mujoco.MjModel, mujoco.MjData]: 
  """ loads scene/model from xml path """
  model = mujoco.MjModel.from_xml_path(path)
  data  = mujoco.MjData(model)
  mujoco.mj_forward(model, data)
  return model, data


def __compute_err(data: mujoco.MjData, target_idx: int, ee_idx: int) -> np.ndarray:
  """ computes linear err w.r.t. world frame. outputs: `err_lin`: (3, )"""
  target_pos = data.xpos[target_idx].copy()
  ee_pos = data.site_xpos[ee_idx].copy()
  return target_pos - ee_pos 


def __compute_err_mat(data: mujoco.MjData, target_mat: np.ndarray, ee_idx: int) -> np.ndarray: 
  """ computes rot. err vector w.r.t. world frame. outputs: `err_rot`: (3,)"""
  assert np.allclose(target_mat.T @ target_mat, np.eye(3), atol=1e-6)
  ee_mat = data.site_xmat[ee_idx].reshape(3,3).copy()
  return __vee(__Log(target_mat @ ee_mat.T))


def __hat(w: np.ndarray) -> np.ndarray: 
  """ hat operator. returns skew symmetric matrix generated by a (3,) vector `w`. returns: skew symmetric matrix `S`: (3,3) """
  assert w.size == 3
  wx, wy, wz = w
  return np.array([[0, -wz, wy],
                   [wz, 0, -wx],
                   [-wy, wx, 0]], dtype=float)


def __vee(R: np.ndarray) -> np.ndarray: 
  """ vee operator. returns vector `phi`: (3,) from skew symmetric matrix `S`: (3,3) """
  assert R.shape == (3,3) and np.linalg.norm(R + R.T) < 1e-6 # applies frobenius matrix norm check
  wx, wy, wz = R[2,1], R[0,2], R[1,0]
  return np.array([wx, wy, wz], dtype=float)


def __Log(R: np.ndarray, eps: float=1e-6) -> np.ndarray: 
  """ log operator, principal branch. returns (3,3) velocity `phi^` in so(3) lie algebra that generates R in SO(3)"""
  th = np.arccos(0.5*(np.trace(R) - 1)) # noclip fail fast 
  if th < eps: 
    return 0.5 * (R - R.T)
  return 0.5 * th/np.sin(th) * (R - R.T)


def Jl_inv(phi: np.ndarray, eps: float=1e-6) -> np.ndarray: 
  """ computes the left inverse jacobian w.r.t. world frame. input: `phi`: (3,). output: `Jl_inv` (3,3)"""
  th = np.linalg.norm(phi)
  hat_phi = __hat(phi)
  I3 = np.eye(3)
  if th < eps: 
    return I3 + 0.5 * hat_phi + 1.0/12.0 * hat_phi @ hat_phi
  return I3 + 0.5 * hat_phi + (1/(th * th) - (1 + np.cos(th))/(2 * th * np.sin(th))) * hat_phi @ hat_phi


if __name__ == "__main__": 
  # load model, data
  model, data = __load_model("data/kuka_iiwa_14/scene.xml")
  target_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, "target_box")
  ee_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_SITE, "attachment_site")

  # preallocate jacobians 
  nq = model.nq
  nv = model.nv 
  Jp = np.zeros((3,nv))
  Jr = np.zeros((3,nv))

  # desired ee orientation 
  zd = np.array([0,0,-1], dtype=float)
  up = np.array([0,1,0],dtype=float)
  xd = np.cross(up, zd); xd /= np.linalg.norm(xd) # gram schmidt orthogonalization, we care only about zdown 
  yd = np.cross(zd, xd)
  target_mat = np.column_stack((xd,yd,zd))

  # sim params 
  dt = model.opt.timestep
  lam = 1e-3 
  alpha = 0.2 
  tol = 1e-6
  max_iter = 1000
  I6 = np.eye(6)
  for k in range(max_iter): 
    mujoco.mj_forward(model, data)
    mujoco.mj_jacSite(model, data, Jp, Jr, ee_id)

    #solve: 
    # dq = Je.T @ (Je @ Je.T + lam * I6)^-1 @ e 
    # let y = Je.T^-1 dq, then Ay = e, solve this 
    # where A = Je @ Je.T + lam * I6
    # then dq = Je.T @ y
    err_lin, phi = __compute_err(data, target_id, ee_id), __compute_err_mat(data, target_mat, ee_id)
    err = np.concatenate((err_lin, phi))
    Je = np.vstack((Jp, Jl_inv(phi) @ Jr))

    A = Je @ Je.T + lam * I6
    y = np.linalg.solve(A, err)
    dq = Je.T @ y

    # update 
    data.qpos[:nq] += alpha * dq[:nq]
    if np.linalg.norm(err) < tol: 
      print(f"IK Converged at iteration {k} with ||err||: ", np.linalg.norm(err))
      break

  # retrieve ik solution 
  print("qpos_f: ", data.qpos) 
  q_des = data.qpos.copy()
  mujoco.mj_resetDataKeyframe(model, data, 0)

  kp = model.actuator_gainprm[:model.nu, 0].copy()      
  view = False
  viewer = None 
  if view: 
    viewer = mujoco.viewer.launch_passive(model, data)
  dt = 0.002
  Nsteps = 5000 # 5000 steps = 10s at dt=0.002
  for i in range(Nsteps):   
      mujoco.mj_forward(model, data)
      data.ctrl[:nq] = q_des + data.qfrc_bias[:nq].copy() / kp
      if i % 500 == 0:
          print(i, "||q-qdes||", np.linalg.norm(data.qpos[:nq] - q_des[:nq]), 
                   "||qdot||",  np.linalg.norm(data.qvel[:nq]))
      if np.linalg.norm(data.qvel[:nq]) < 1e-6 and np.linalg.norm(data.qpos[:nq]-q_des[:nq]) < 1e-3:
          print(f"ee pose converged in {i} iterations.")
          break
      mujoco.mj_step(model,data)

      if view and viewer is not None: 
        viewer.sync()
        time.sleep(10*dt)

  # debug info 
  print("linear ||err_f||: ", np.linalg.norm(__compute_err(data, target_id, ee_id)))
  print("rot ||err_f||: ", np.linalg.norm(__compute_err_mat(data, target_mat, ee_id))) # matrix frobenius norm 

  # qfrc metadata 
  print("qacc norm:", np.linalg.norm(data.qacc[:nq]))
  print("qfrc_constraint norm:", np.linalg.norm(data.qfrc_constraint[:nq]))
  print("qfrc_passive norm:", np.linalg.norm(data.qfrc_passive[:nq]))
  print("qfrc_bias:", data.qfrc_bias[:nq])
  print("qfrc_actuator:", data.qfrc_actuator[:nq])

  # distance to joint limits 
  q = data.qpos[:nq]
  lo = model.jnt_range[:nq,0]
  hi = model.jnt_range[:nq,1]
  print("min dist to lo:", np.min(q-lo))
  print("min dist to hi:", np.min(hi-q))

  # contacts info 
  print("ncon:", data.ncon)
  for i in range(data.ncon):
      c = data.contact[i]
      g1 = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_GEOM, c.geom1)
      g2 = mujoco.mj_id2name(model, mujoco.mjtObj.mjOBJ_GEOM, c.geom2)
      print(i, g1, "<->", g2, "dist:", c.dist)