from __future__ import annotations

import numpy as np 


def hat(w: np.ndarray) -> np.ndarray: 
  """ hat operator. returns skew symmetric matrix generated by a (3,) vector `w`. returns: skew symmetric matrix `S`: (3,3) """
  assert w.size == 3
  wx, wy, wz = w
  return np.array([[0, -wz, wy],
                   [wz, 0, -wx],
                   [-wy, wx, 0]], dtype=float)


def vee(R: np.ndarray) -> np.ndarray: 
  """ vee operator. returns vector `phi`: (3,) from skew symmetric matrix `S`: (3,3) """
  assert R.shape == (3,3) and np.linalg.norm(R + R.T) < 1e-6 # applies frobenius matrix norm check
  wx, wy, wz = R[2,1], R[0,2], R[1,0]
  return np.array([wx, wy, wz], dtype=float)


def Log(R: np.ndarray, eps: float=1e-6) -> np.ndarray: 
  """ log operator, principal branch. returns (3,3) velocity `phi^` in so(3) lie algebra that generates R in SO(3)"""
  th = np.arccos(0.5*(np.trace(R) - 1)) # noclip fail fast 
  if th < eps: 
    return 0.5 * (R - R.T)
  return 0.5 * th/np.sin(th) * (R - R.T)


def Jl_inv(phi: np.ndarray, eps: float=1e-6) -> np.ndarray: 
  """ computes the left inverse jacobian w.r.t. world frame. input: `phi`: (3,). output: `Jl_inv` (3,3)"""
  th = np.linalg.norm(phi)
  hat_phi = hat(phi)
  I3 = np.eye(3)
  if th < eps: 
    return I3 + 0.5 * hat_phi + 1.0/12.0 * hat_phi @ hat_phi
  return I3 + 0.5 * hat_phi + (1/(th * th) - (1 + np.cos(th))/(2 * th * np.sin(th))) * hat_phi @ hat_phi